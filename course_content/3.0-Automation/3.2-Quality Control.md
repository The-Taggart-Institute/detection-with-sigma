# 3.2 :: Quality Control

Now that we've got rules automatically being pulled from our GitHub repo and being dropped directly into our production environment, we can take a breather and go touch some grass, right? Nothing has ever gone wrong with automating unchecked code directly to production.

Okay... if you really *want* to make sure that your rules are validated and functional, we have a few tools available to us to ensure only high quality detections make it into your SIEM.

## Workflows

GitHub's automated workflow system allows us to run jobs as defined in YAML files in that are defined in the `.github/workflows` folder of our repo. These jobs can perform a variety of tasks and we will use them to check every pull request in our repo to ensure only high quality detections make it past our filters. If you wanted to you could even use a workflow to replace the actions we built in our previous chapter - the automation of pushing our converted rules directly to our SIEM.

I will cover some of the basics but you can learn more about GitHub workflows [here](https://docs.github.com/en/actions/using-workflows/about-workflows).

At a high level a workflow waits for an event to trigger the workflow and will then assign a runner to execute the tasks defined for the associated job. These tasks are often scripts that execute in a sequential order.

Let's walk through one of the workflows we'll be using:

```yaml
# This workflow will install Python dependencies, run tests and lint with a single version of Python
# For more information see: https://help.github.com/actions/language-and-framework-guides/using-python-with-github-actions

name: Sigma Rule Tests

on:
  push:
    branches:
      - "*"
    paths:
      - ".github/workflows/sigma-test.yml"
      - "deprecated/**.yml"
      - "rules/**.yml"
      - "tests/test_logsource.py"
      - "tests/test_rules.py"
  pull_request:
    branches:
      - main
    paths:
      - ".github/workflows/sigma-test.yml"
      - "deprecated/**.yml"
      - "rules/**.yml"
      - "tests/test_logsource.py"
      - "tests/test_rules.py"

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

jobs:
  yamllint:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - name: yaml-lint
      uses: ibiqlik/action-yamllint@v3

  test-sigma-logsource:
    runs-on: ubuntu-latest
    needs: yamllint
    steps:
    - uses: actions/checkout@v4
      with:
        submodules: true
    - name: Set up Python 3.11
      uses: actions/setup-python@v5
      with:
        python-version: 3.11
    - name: Test Sigma logsource
      run: |
        pip install PyYAML colorama
        python tests/test_logsource.py

  test-sigma:
    runs-on: ubuntu-latest
    needs: test-sigma-logsource
    steps:
    - uses: actions/checkout@v4
      with:
        submodules: true
    - name: Set up Python 3.11
      uses: actions/setup-python@v5
      with:
        python-version: 3.11
    - name: Install dependencies
      run: |
        # pip install sigma-cli~=0.7.1
        pip install sigma-cli
    - name: Test Sigma Rule Syntax
      run: |
        sigma check --fail-on-error --fail-on-issues --validation-config tests/sigma_cli_conf.yml rules*
    - name: Test Sigma Rules
      run: |
        pip install PyYAML colorama
        python tests/test_rules.py
```

In this workflow we are defining the triggers in the `on:` section with the `push:` and `pull_request:` keywords. Then we are defining the `jobs:` that we'll be running. Looking closer at one of the jobs:

```yaml
  yamllint:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - name: yaml-lint
      uses: ibiqlik/action-yamllint@v3
```
we have the name of the job, `yamllint`, the system or image it will run on, `ubuntu-latest`, and the steps that job will take. The steps can `use` GitHub actions and in this case we're using `actions/checkout@v4` which will checkout the repository onto our runner, allowing the following scripts to have access to that code. Then we name our script `yaml-lint` and use another action from [another GitHub action library](https://github.com/ibiqlik/action-yamllint) to actually do perform an action.

In this case we are running a yaml linter which is a tool that will make sure that the syntax and formatting in your Sigma rules matches the agreed upon standard of the yaml format. There are specific checks that we modify from the standards for Sigma rules and those are defined in the `.yamllint` file in the root of our GitHub repo.

The next two jobs that we run in this workflow are Python scripts to validate that we are using proper logsources and field names as defined in the script `/tests/test_logsource.py` (with the helper file `/tests/logsource.json`) and then a test to validate that our Sigma rule will properly convert using sigma-cli and the script `/tests/test_rules.py`.




## Peer Review